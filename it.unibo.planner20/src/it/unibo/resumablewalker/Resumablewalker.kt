/* Generated by AN DISI Unibo */ 
package it.unibo.resumablewalker

import it.unibo.kactor.*
import alice.tuprolog.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
	
class Resumablewalker ( name: String, scope: CoroutineScope  ) : ActorBasicFsm( name, scope ){

	override fun getInitialState() : String{
		return "s0"
	}
	@kotlinx.coroutines.ObsoleteCoroutinesApi
	@kotlinx.coroutines.ExperimentalCoroutinesApi			
	override fun getBody() : (ActorBasicFsm.() -> Unit){
		  var CurrentPlannedMove = ""
			val mapname                    = "roomMap"
			var storedPos  : Pair<Int,Int> = Pair(0,0)
			var planInterrupted            = false
			var StepTime                   = 500L
			val TargetPos                  = Pair(4,4)
			val  GoalX                     = TargetPos.first
			val  GoalY                     = TargetPos.second 
		return { //this:ActionBasciFsm
				state("s0") { //this:State
					action { //it:State
						println("&&&  resumablewalker STARTED")
						itunibo.planner.plannerUtil.initAI(  )
						itunibo.planner.plannerUtil.loadRoomMap( mapname  )
						println("INITIAL MAP")
						itunibo.planner.plannerUtil.showMap(  )
						 
									emitWithDelay("alarm", "alarm(fire)",500L)
					}
					 transition( edgeName="goto",targetState="moveToTargetPoint", cond=doswitch() )
				}	 
				state("moveToTargetPoint") { //this:State
					action { //it:State
						itunibo.planner.plannerUtil.planForGoal( "${GoalX}", "${GoalY}"  )
					}
					 transition( edgeName="goto",targetState="execPlannedMoves", cond=doswitch() )
				}	 
				state("execPlannedMoves") { //this:State
					action { //it:State
						  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove()  
						if(  CurrentPlannedMove.length > 0  
						 ){forward("doMove", "doMove($CurrentPlannedMove)" ,"resumablewalker" ) 
						}
						stateTimer = TimerActor("timer_execPlannedMoves", 
							scope, context!!, "local_tout_resumablewalker_execPlannedMoves", 100.toLong() )
					}
					 transition(edgeName="t00",targetState="endJob",cond=whenTimeout("local_tout_resumablewalker_execPlannedMoves"))   
					transition(edgeName="t01",targetState="handleAlarm",cond=whenEvent("alarm"))
					transition(edgeName="t02",targetState="execTheMove",cond=whenDispatch("doMove"))
				}	 
				state("handleAlarm") { //this:State
					action { //it:State
						println("$name in ${currentState.stateName} | $currentMsg")
						 planInterrupted = true
						 			storedPos = itunibo.planner.plannerUtil.get_curPos() 
						 			itunibo.planner.plannerUtil.memoCurentPlan()
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
						if(  ! itunibo.planner.plannerUtil.atPos(GoalX, GoalY)  
						 ){request("movetoCell", "movetoCell(0,0)" ,"insensitivewalker" )  
						}
					}
					 transition( edgeName="goto",targetState="endJob", cond=doswitchGuarded({  itunibo.planner.plannerUtil.atPos(GoalX, GoalY)  
					}) )
					transition( edgeName="goto",targetState="waitBackHome", cond=doswitchGuarded({! (  itunibo.planner.plannerUtil.atPos(GoalX, GoalY)  
					) }) )
				}	 
				state("endJob") { //this:State
					action { //it:State
						println("&&&  resumablewalker POINT ${GoalX},${GoalY} REACHED")
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
					}
				}	 
				state("waitBackHome") { //this:State
					action { //it:State
					}
					 transition(edgeName="t03",targetState="atHomeAgain",cond=whenReply("atcell"))
				}	 
				state("atHomeAgain") { //this:State
					action { //it:State
						println("resumablewalker atHomeAgain")
						if(  planInterrupted  
						 ){ val XOLD = storedPos.first
									   val YOLD = storedPos.second	
						request("movetoCell", "movetoCell($XOLD,$YOLD)" ,"insensitivewalker" )  
						}
					}
					 transition(edgeName="t04",targetState="resumeOldPlan",cond=whenReply("atcell"))
				}	 
				state("execTheMove") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("doMove(V)"), Term.createTerm("doMove(M)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								delay(StepTime)
								 val move = payloadArg(0)
								  			   itunibo.planner.plannerUtil.updateMap(move,"resumablewalker: exec $move") 			   
						}
					}
					 transition( edgeName="goto",targetState="execPlannedMoves", cond=doswitch() )
				}	 
				state("resumeOldPlan") { //this:State
					action { //it:State
						println("-------------------------------------------------------------------")
						println("resumablewalker resumeOldPlan to reach POINT ${TargetPos.first},${TargetPos.second}")
						println("-------------------------------------------------------------------")
						itunibo.planner.plannerUtil.showCurrentRobotState(  )
						itunibo.planner.plannerUtil.restorePlan(  )
						 readLine()  
						 
									emitWithDelay("alarm", "alarm(fire)",3000L)
						stateTimer = TimerActor("timer_resumeOldPlan", 
							scope, context!!, "local_tout_resumablewalker_resumeOldPlan", 50.toLong() )
					}
					 transition(edgeName="t05",targetState="execPlannedMoves",cond=whenTimeout("local_tout_resumablewalker_resumeOldPlan"))   
					transition(edgeName="t06",targetState="execTheOldMove",cond=whenDispatch("doMove"))
				}	 
				state("execTheOldMove") { //this:State
					action { //it:State
						if( checkMsgContent( Term.createTerm("doMove(V)"), Term.createTerm("doMove(M)"), 
						                        currentMsg.msgContent()) ) { //set msgArgList
								delay(StepTime)
								 val move = payloadArg(0)
								  			   itunibo.planner.plannerUtil.updateMap(move,"resumablewalker: OLD MOVE $move")
						}
						stateTimer = TimerActor("timer_execTheOldMove", 
							scope, context!!, "local_tout_resumablewalker_execTheOldMove", 50.toLong() )
					}
					 transition(edgeName="t07",targetState="execPlannedMoves",cond=whenTimeout("local_tout_resumablewalker_execTheOldMove"))   
					transition(edgeName="t08",targetState="execTheOldMove",cond=whenDispatch("doMove"))
				}	 
				state("execOldPlannedMove") { //this:State
					action { //it:State
						println("resumablewalker execOldPlannedMove")
						 readLine()  
						stateTimer = TimerActor("timer_execOldPlannedMove", 
							scope, context!!, "local_tout_resumablewalker_execOldPlannedMove", 50.toLong() )
					}
					 transition(edgeName="t09",targetState="execPlannedMoves",cond=whenTimeout("local_tout_resumablewalker_execOldPlannedMove"))   
					transition(edgeName="t010",targetState="execOldPlannedMove",cond=whenDispatch("doMove"))
				}	 
				state("discardOldMoveTodo") { //this:State
					action { //it:State
						println("resumablewalker discardOldMovesTodo")
						stateTimer = TimerActor("timer_discardOldMoveTodo", 
							scope, context!!, "local_tout_resumablewalker_discardOldMoveTodo", 50.toLong() )
					}
					 transition(edgeName="t011",targetState="execPlannedMoves",cond=whenTimeout("local_tout_resumablewalker_discardOldMoveTodo"))   
					transition(edgeName="t012",targetState="discardOldMoveTodo",cond=whenDispatch("doMove"))
				}	 
			}
		}
}
