/*
 * sonarResource.qak
 * A CoAP-observable component
 * 1) launch sonarresource
 * 2) launch SonarresourceObserver or SonarresourceObserverRadar
 * 3a) launch SimulateSonarData that reads  data from the user console and emits the event 
 *             msg(sonarrobot,event,support,none,sonar(data),1)
 * 3b) launch on Raspberry an emitter of sonarRobot event e.g. sonar in sonarnaive.qak
 *    that launches a CodedQactor that reads data from SonarAlone and emits the event
 * 	            msg(sonarrobot,event,sonarHCSR04Support,none,sonar(data),1)
 */ 
   
System /* -trace */ sonarresource  
//mqttBroker "192.168.1.45" : 1883  eventTopic "sonar/data"		//broker.hivemq.com

 
Event    local_appl   : job(X)
Event    local_update : value(X)

Event    sonarrobot : sonar( V )
Dispatch sonarrobot : sonar( V )
Request  sonarrobot : sonar( V )
Reply    replysonar : updated(V)

Context ctxsonarresource ip [ host= "192.168.1.45"   port= 8028 ]

QActor sonarresource context ctxsonarresource{ 
	State s0 initial{  
		//println("onarresource | start") 
	}
	Goto work
	 
	State work{
		println("sonarresource | waits ... ") 
	}
	Transition t0 whenEvent local_update -> doUpdate
			      whenMsg   sonarrobot   -> handleSonarData
	              whenEvent sonarrobot   -> handleSonarData
	              
	              
	State handleSonarData{ 
		printCurrentMessage
		onMsg( sonarrobot : sonar(V) ){
			[# val Distance = payloadArg(0) #]
			emit local_appl : job(sonarrobot($Distance))  //run the business logic
			/* 
			updateResource [# "{\"sonarvalue\":\"$Distance\"}" #]  	//JSON rep for resource
			//updateResource [# "{\"sonarvalue\":\"$Distance\", \"info\":\"$Distance\"}" #]  	 
 			println("onarresource | distance=$Distance")
 			delay 1000 
 			//The resource changes its representation in autonomous way ...
 			updateResource [# "{\"info\":\"$Distance\"}" #]  
 			* 
 			*/
		}	 	
	} 
	Goto work
	
	State doUpdate{
		printCurrentMessage
		onMsg( local_update : value( sonarrobot(D) ) ){
			println("DISTANCE")
			[# val V  = payloadArg(0) 
			   val D  = applsupport.getSonarDistance( V ) #
			]
			updateResource [# "{\"sonarvalue\":\"$D\"}" #]  	//JSON rep for resource			
		}
		onMsg( local_update : value( led(V) ) ){
			println("LED")
		}
	}
	Goto work
}

/*
 * rapid test
*/ 
 
QActor sendermock context ctxsonarresource{
[# val input   = java.util.Scanner(System.`in`) #]
	State s0 initial{ 
		println("sendermock start") 
		emit sonarrobot : sonar(50)	
		forward sonarresource -m sonarrobot : sonar(10)		
	}
	//Goto work	//WARNING: input.nextLine() BLOCKS (also sonarresource)
	 
	State work{
		delay 500     //release the resource
		[# print("VALUE>")
			var Data = input.nextLine() #] 
		emit sonarrobot : sonar($Data)
	}
	Goto work
	
} 

QActor appl context ctxsonarresource{ 
	State s0 initial{  
		println("appl | start") 
   		/*
 		 * LOAD APPLICATION RULES
 		*/ 
		solve( consult("sysRules.pl")	 )
 		solve( consult("applRulesKb.pl") )
 		solve( led(X) )
		//println( currentSolution )	//yes X/on oppure X/off
		[# val x = getCurSol("X").toString() 
 		   println( "appl | led $x" )
		#] 		
	}
	Goto waitwork
	
	State waitwork{
		
	}
	Transition t0 whenEvent local_appl -> work
	
	State work{
		printCurrentMessage
		onMsg( local_appl : job( X ) ){
			[#  val D  = applsupport.getSonarDistance( payloadArg(0) )
				solve( "modifyResource($D,R)" )
				//println( currentSolution )
				val DoResource = getCurSol("R")
				println( "DoResource=$DoResource" )
				
				solve( "modifyLed($D,20,RT)" )
				val DoLed  = getCurSol("RT")
			#]  
			if[# DoResource =="ok" #] { emit local_update : value( sonarrobot($D) ) }
			if[# DoLed      =="ok" #] { emit local_update : value( led(on) ) }
			else { emit local_update : value( led(off) ) }
			
			//println("worktodo($Jobtodo)")
		}
	}
	Goto waitwork
}
	 

 
